// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {SelfAuthorized} from "./SelfAuthorized.sol";

/**
 * @title OwnerManager - Manages owners and a threshold to authorize transactions
 * @dev Uses a linked list to store the owners because the code generated by the solidity compiler
 *      is more efficient than using a dynamic array
 */
abstract contract OwnerManager is SelfAuthorized {
    /**
     * SENTINEL_OWNERS is used to traverse `owners`, so that:
     *      1. `owners[SENTINEL_OWNERS]` contains the first owner
     *      2. `owners[last_owner]` points back to SENTINEL_OWNERS
     */
    /* solhint-disable private-vars-leading-underscore */
    address internal constant SENTINEL_OWNERS = address(0x1);
    /* solhint-enable private-vars-leading-underscore */

    // Error codes
    error AlreadyInitialized();
    error WrongInput();
    error WrongOwnerAddress();
    error ThresholdNotReachable();

    /**
     * @notice Emitted when an owner is added to the linked list
     * @param owner The address of the owner that was added
     */
    event OwnerAdded(address indexed owner);

    /**
     * @notice Emitted when an owner is removed from the linked list
     * @param owner The address of the owner that was removed
     */
    event OwnerRemoved(address indexed owner);

    /**
     * @notice Emitted when the threshold is changed
     * @param threshold The new threshold value
     */
    event ThresholdChanged(uint256 threshold);

    /// @dev Mapping that stores the owners working as a linked list
    mapping(address => address) internal _owners;

    /// @dev The number of owners in the linked list
    uint256 internal _ownerCount;

    /// @dev The threshold to reach to authorize a transaction
    uint256 internal _threshold;

    /**
     * @dev Initializes the owners and threshold
     * @param owners The addresses of the owners to initialize
     * @param threshold The threshold to reach to authorize a transaction
     */
    function _setupOwners(address[] memory owners, uint256 threshold) internal {
        // Threshold can only be 0 at initialization
        if (_threshold > 0) revert AlreadyInitialized();

        // Validate that the threshold is smaller than the number of added owners
        if (threshold > owners.length || threshold == 0) revert WrongInput();

        // Initializing MultiSigWallet owners
        address currentOwner = SENTINEL_OWNERS;
        uint256 ownersLength = owners.length;
        for (uint256 i = 0; i < ownersLength; ++i) {
            // Owner address cannot be null or duplicate
            address owner = owners[i];
            if (owner == address(0) || owner == SENTINEL_OWNERS || owner == address(this) || _owners[owner] != address(0)) revert WrongOwnerAddress();

            _owners[currentOwner] = owner;
            currentOwner = owner;
        }

        _owners[currentOwner] = SENTINEL_OWNERS;
        _ownerCount = ownersLength;
        _threshold = threshold;
    }

    /**
     * @notice Adds an owner to the linked list
     * @dev The owner address cannot be null, the sentinel, the MultiSigWallet itself or duplicate
     *      NOTE: This contract is only called by the MultiSigWallet contract
     * @param owner The address of the owner to add
     */
    function addOwner(address owner) public authorized {
        // Owner address cannot be null, the sentinel, the MultiSigWallet itself or duplicate
        if (owner == address(0) || owner == SENTINEL_OWNERS || owner == address(this) || _owners[owner] != address(0)) revert WrongOwnerAddress();

        _owners[owner] = _owners[SENTINEL_OWNERS];
        _owners[SENTINEL_OWNERS] = owner;

        ++_ownerCount;

        emit OwnerAdded(owner);
    }

    /**
     * @notice Removes an owner from the linked list
     * @dev Count of owners must be greater than the threshold after removing the owner
     *      NOTE: This contract is only called by the MultiSigWallet contract
     * @param prevOwner The address of the previous owner in the linked list
     * @param owner The address of the owner to remove
     */
    function removeOwner(address prevOwner, address owner) public authorized {
        // Only allow to remove an owner, if threshold can still be reached
        // Here we do pre-decrement as it is cheaper and allows us to check if the threshold is still reachable
        if (--_ownerCount < _threshold) revert ThresholdNotReachable();

        // Validate owner address and check that it corresponds to owner index
        if (owner == address(0) || owner == SENTINEL_OWNERS || _owners[prevOwner] != owner) revert WrongOwnerAddress();

        _owners[prevOwner] = _owners[owner];
        _owners[owner] = address(0);

        emit OwnerRemoved(owner);
    }

    /**
     * @notice Changes the threshold to a new value
     * @dev The new threshold must be smaller than the number of owners and greater than 0
     *      NOTE: This contract is only called by the MultiSigWallet contract
     * @param threshold The new threshold value
     */
    function changeThreshold(uint256 threshold) public authorized {
        // Validate that threshold is smaller than number of owners
        if (threshold > _ownerCount || threshold == 0) revert WrongInput();

        _threshold = threshold;

        emit ThresholdChanged(threshold);
    }

    /// @notice Returns the threshold value
    function getThreshold() public view returns (uint256) {
        return _threshold;
    }

    /// @notice Returns if the address is an owner
    function isOwner(address owner) public view returns (bool) {
        return owner != SENTINEL_OWNERS && _owners[owner] != address(0);
    }

    /// @notice Returns the owners in the linked list
    function getOwners() public view returns (address[] memory) {
        address[] memory array = new address[](_ownerCount);

        // populate return array
        uint256 index = 0;
        address currentOwner = _owners[SENTINEL_OWNERS];
        while (currentOwner != SENTINEL_OWNERS) {
            array[index] = currentOwner;
            currentOwner = _owners[currentOwner];
            ++index;
        }
        return array;
    }
}
