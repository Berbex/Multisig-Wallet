// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {SelfAuthorized} from "./SelfAuthorized.sol";

/**
 * @title OwnerManager - Manages Safe owners and a threshold to authorize transactions
 * @dev Uses a linked list to store the owners because the code generated by the solidity compiler
 *      is more efficient than using a dynamic array
 */
abstract contract OwnerManager is SelfAuthorized {
    // SENTINEL_OWNERS is used to traverse `owners`, so that:
    //      1. `owners[SENTINEL_OWNERS]` contains the first owner
    //      2. `owners[last_owner]` points back to SENTINEL_OWNERS
    /* solhint-disable private-vars-leading-underscore */
    address internal constant SENTINEL_OWNERS = address(0x1);
    /* solhint-enable private-vars-leading-underscore */

    error AlreadyInitialized();

    error WrongInput();

    error WrongOwnerAddress();

    error ThresholdNotReachable();

    event OwnerAdded(address indexed owner);

    event OwnerRemoved(address indexed owner);

    event ThresholdChanged(uint256 threshold);

    mapping(address => address) internal _owners;

    uint256 internal _ownerCount;

    uint256 internal _threshold;

    function _setupOwners(address[] memory owners, uint256 threshold) internal {
        // Threshold can only be 0 at initialization
        if (_threshold > 0) revert AlreadyInitialized();

        // Validate that the threshold is smaller than the number of added owners
        if (threshold > owners.length || threshold == 0) revert WrongInput();

        // Initializing Safe owners
        address currentOwner = SENTINEL_OWNERS;
        uint256 ownersLength = owners.length;
        for (uint256 i = 0; i < ownersLength; ++i) {
            // Owner address cannot be null or duplicate
            address owner = owners[i];
            if (owner == address(0) || owner == SENTINEL_OWNERS || owner == address(this) || currentOwner == owner || _owners[owner] != address(0))
                revert WrongOwnerAddress();

            _owners[currentOwner] = owner;
            currentOwner = owner;
        }

        _owners[currentOwner] = SENTINEL_OWNERS;
        _ownerCount = ownersLength;
        _threshold = threshold;
    }

    function addOwner(address owner) public authorized {
        // Owner address cannot be null, the sentinel, the Safe itself or duplicate
        if (owner == address(0) || owner == SENTINEL_OWNERS || owner == address(this) || _owners[owner] != address(0)) revert WrongOwnerAddress();

        _owners[owner] = _owners[SENTINEL_OWNERS];
        _owners[SENTINEL_OWNERS] = owner;

        ++_ownerCount;

        emit OwnerAdded(owner);
    }

    function removeOwner(address prevOwner, address owner) public authorized {
        // Only allow to remove an owner, if threshold can still be reached
        // Here we do pre-decrement as it is cheaper and allows us to check if the threshold is still reachable
        if (--_ownerCount < _threshold) revert ThresholdNotReachable();

        // Validate owner address and check that it corresponds to owner index
        if (owner == address(0) || owner == SENTINEL_OWNERS || _owners[prevOwner] != owner) revert WrongOwnerAddress();

        _owners[prevOwner] = _owners[owner];
        _owners[owner] = address(0);

        emit OwnerRemoved(owner);
    }

    function changeThreshold(uint256 threshold) public authorized {
        // Validate that threshold is smaller than number of owners
        if (threshold > _ownerCount || threshold == 0) revert WrongInput();

        _threshold = threshold;

        emit ThresholdChanged(threshold);
    }

    function getThreshold() public view returns (uint256) {
        return _threshold;
    }

    function isOwner(address owner) public view returns (bool) {
        return owner != SENTINEL_OWNERS && _owners[owner] != address(0);
    }

    function getOwners() public view returns (address[] memory) {
        address[] memory array = new address[](_ownerCount);

        // populate return array
        uint256 index = 0;
        address currentOwner = _owners[SENTINEL_OWNERS];
        while (currentOwner != SENTINEL_OWNERS) {
            array[index] = currentOwner;
            currentOwner = _owners[currentOwner];
            ++index;
        }
        return array;
    }
}
